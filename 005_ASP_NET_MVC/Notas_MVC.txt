MVC
    MVC es el significado de:
        - Modelo 
            - Información de la aplicación y el comportamiento en términos del dominio de su problema y es independiente de la interfaz gráfica.
            - Solo representa la información y no está ligada a la interfaz gráfica.
            - En el modelo se incluyen entidades como pelicula, cliente, renta, transacción, pero ninguna relacionada a la interfaz.
            - Son representados como POCOs (Plain Old CLR Objects).
        - Vista
            - Representa la parte gráfica de la aplicación, en programación web el código html y css.
        - Controlador
            - Es el responsable de manejar la petición http para consultar el modelo y de ahi mandar la información a la vista.
    - Es un patrón de arquitectura para implementar interfaces gráficas.
    - Diseñada en 1970.
    - Muy usada en la web.
    - Se encuentra en ASP.NET, Ruby on Rails y Express entre otros.
    - Otorga la caracterísitca de dar mejor mantenimiento al proyecto y una mejor separación de responsabilidades.
Al crear el proyecto en ASP.NET con MVC tenemos:
    App_Data:
        - Lugar donde se guarda el archivo de base de datos.
    App_Start:
        - Incluye las clases que se van a llamar cuando la aplicación se inicializa.
        Archivo RouteConfig.cs:
            - Contiene información de las rutas a usar.
            - Por defecto contiene una ruta con el nombre default, con un patrón de url asignado, si se empareja con ese patrón Coincidera conforme lo indicado.
            public static void RegisterRoutes(RouteCollection routes)
            {
                routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

                routes.MapRoute( // Realiza el routing para mandarlo a un controlador.
                    name: "Default", // Nombre de patrón a usar.
                    url: "{controller}/{action}/{id}", // Url con el formato del patron.
                    // Asigna la primera parte de la ruta a la variable controller.
                    // Asigna la segunda parte de la ruta a la variable action.
                    // Asigna la tercera parte de la ruta a la variable id.
                    defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional } // Ejecuta un método por defecto si no cumplió con el patrón de la ruta, asignando valores default para los casos no dados.
                );
            }
            - Llama a la clase controller indicada, action ejecuta el método de la clase controller indicado y pasa el parámetro si se asignó.
            - En la opción defaults asigna los parámetros si no se pasaron, si solo se paso el controlador, por defecto llama a la acción indicada en action.
            - Ruta: /movies/popular
                - movies (controller): Coincide a MoviesController.
                - popular (action): Coincide al método Popular de la clase MoviesController.
            - Ruta: /movies/edit/1
                - movies (controller): Coincide a MoviesController.
                - edit (action): Coincide al método Edit(int id) de la clase MoviesController.
                - 1 (id): Pasa el parámetro id al método Edit(int id), como el tipo declarado en el método.
            - Ruta: /movies:
                - movies (controller): Coincide a MoviesController.
                - Index (action): Llama a la acción por defecto MoviesController.Index().
                - Opcional (id): Al ser UrlParameter.Optional no asigna nada pues el parámetro id es declarado como opcional.
    - Content:
        - En esta carpeta se guardan los archivos css para dar estilos y formato a las vistas.
        - También se acostumbra guardar imágenes necesarias, contenido multimedia de la página y otros assets.
    - Controllers:
        - Aquí se guardan todos lo controladores que servirán de medio para obtener la información de los métodos http y procesarla para mostrar una respuesta en la vista.
        - Por defecto tiene el HomeController el cual nos va a enviar a la página home del sitio.
            public class HomeController : Controller
            {
                public ActionResult Index()
                {
                    return View();
                }

                public ActionResult About()
                {
                    ViewBag.Message = "Your application description page.";

                    return View();
                }

                public ActionResult Contact()
                {
                    ViewBag.Message = "Your contact page.";

                    return View();
                }
            }
    - Fonts:
        - Carpeta donde se guardan los distintos estilos de letra a usar en la aplicación, es recomdable moverlo a la carpeta de contenido.
    - Models:
        - Aqui se guardan todas las clases de nuestra aplicación de dominio como entidades o cálculos de la lógica de negocio.
    - Scripts:
        - Carpeta donde se guardan los archivos de javascript necesarios para el funcionamiento de la aplicación.
    - Views:
        - Carpeta donde se guardan las distintas vistas (html) de la aplicación.
        - Por cada controlador debe haber una carpeta de vistas con el mismo nombre y dentro de cada carpeta una vista por cada metodo de la aplicación.
        - Para HomeController está la carpeta Controller (dentro de Views) y las vistas que hacen referencia a los métodos del controlador:
            - About.cshtml
            - Contact.cshtml
            - Index.cshtml
        - Además contiene la carpeta shared la cual sirve para compartir un diseño base entre varias vistas.
            - _Layout.cshtml

            - Error.cshtml
        - Contiene un archivo favicon con el cual se presentará la aplicación.
        - Contiene archivo viewstart.cshtml el cual llama por defecto a _Layout.cshtml
            @{
                Layout = "~/Views/Shared/_Layout.cshtml";
            }
        - Diseño por defecto de _Layout.cshtml
            <!DOCTYPE html>
            <html>
            <head>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
                <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>@ViewBag.Title - Mi aplicación ASP.NET</title>
                @Styles.Render("~/Content/css")
                @Scripts.Render("~/bundles/modernizr")
            </head>
            <body>
                <div class="navbar navbar-inverse navbar-fixed-top">
                    <div class="container">
                        <div class="navbar-header">
                            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                            </button>
                            @Html.ActionLink("Nombre de la aplicación", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
                        </div>
                        <div class="navbar-collapse collapse">
                            <ul class="nav navbar-nav">
                                <li>@Html.ActionLink("Inicio", "Index", "Home")</li>
                                <li>@Html.ActionLink("Acerca de", "About", "Home")</li>
                                <li>@Html.ActionLink("Contacto", "Contact", "Home")</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="container body-content">
                    @RenderBody()
                    <hr />
                    <footer>
                        <p>&copy; @DateTime.Now.Year - Mi aplicación ASP.NET</p>
                    </footer>
                </div>

                @Scripts.Render("~/bundles/jquery")
                @Scripts.Render("~/bundles/bootstrap")
                @RenderSection("scripts", required: false)
            </body>
            </html>
    - Global.asax.cs
        - Archivo de incialización de la aplicación.
            public class MvcApplication : System.Web.HttpApplication
            {
                protected void Application_Start()
                {
                    AreaRegistration.RegisterAllAreas();
                    FilterConfig.RegisterGlobalFilters(GlobalFiltersFilters);
                    RouteConfig.RegisterRoutes(RouteTable.Routes);
                    BundleConfig.RegisterBundles(BundleTable.Bundles);
                }
            }
    - package.config
        - Archivo de configuración para saber los paquetes de dependencias de los archivos.

Para crear un nuevo modelo se agrega a la carpeta modelos una nueva clase.
    public class Movie
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

Controladores
    Para crear controladores se pueden usar plantillas predefinidas para agilizar el desarrollo, sin embargo también se pueden crear controladores vacíos.

    public class MovieController : Controller
    {
        // Get Movies/Random
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            return View(); // Llama a la vista de nombre Random.
        }
    }
Vistas
    Para crear la vista se debe verificar la carpeta en la que se creará (con respecto al controlador), si se elige vista parcial la vista actuará como un componente que se pueda llamar a través de varias vistas.

    Además se debe configurar el Layout que la vista usará como base al momento que sea llamada, esto para no repetir código.

    - Código de Vista:
        @{
            ViewBag.Title = "Random";
            Layout = "~/Views/Shared/_Layout.cshtml";
        }

        <h2>Random</h2>
    
    Con @Model podemos leer desde la vista el modelo pasado por el controlador, el cual es dinámico por defecto a menos que se especifique su tipo.

    - Vista con modelo
    @model Vidly.Models.Movie

    @{
        ViewBag.Title = "Random";
        Layout = "~/Views/Shared/_Layout.cshtml";
    }

    <h2>Random</h2>
    <h2>@Model.Name</h2>
Cambio de tema

    Para cambiar el tema por default de la página se puede navegar hacia bootswatch.com y sustituir el tema de bootstrap por defecto que tiene la plantilla.

    En la página se busca el tema deseado y de ahi se descarga el archivo css, posteriormente se guarda en la carpeta content en este caso con el nombre bootstrap-lumen.css .

    - Se abre en App_Start el archivo BundleConfig para cambiar la referencia al archivo css en StyleBundle.

            public class BundleConfig
        {
            // Para obtener más información sobre las uniones, visite https://go.microsoft.com/fwlink/?LinkId=301862
            public static void RegisterBundles(BundleCollection bundles)
            {
                bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                            "~/Scripts/jquery-{version}.js"));

                bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
                            "~/Scripts/jquery.validate*"));

                // Utilice la versión de desarrollo de Modernizr para desarrollar y obtener información. De este modo, estará
                // para la producción, use la herramienta de compilación disponible en https://modernizr.com para seleccionar solo las pruebas que necesite.
                bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
                            "~/Scripts/modernizr-*"));

                bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
                        "~/Scripts/bootstrap.js"));

                bundles.Add(new StyleBundle("~/Content/css").Include(
                        "~/Content/bootstrap-lumen.css",
                        "~/Content/site.css")); // Se cambia el archivo de referencia a css.
            }
        }

    - En bundle config se puede empaquetar varios archivos de js que se manejen juntos, esto para solo hacer una petición http.

Action Result
    - ActionResult es la clase base que se regresa en todas las petiociones que se le hacen al controlador.

    - Dependiendo de lo que realice el controlador puede devolver distintos tipos de respuestas.

    - El método View(movie) es el método base heredado de la clase Controller, el cual nos permite regresar una vista por defecto.

        // Get Movies/Random
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            return View(movie); // Llama a la vista de nombre Random.
            // return new ViewResult(); // Llama a la vista por medio de la creación de una instancia.
        }

    - Cuando se llama al método View(), en realidad se está regresando un ViewResult, por lo cual en el método de regreso también sería valido colocar:
        public ViewResult Random(){return View();}
    
    - Colocar ViewResult es válido es los test para evitar una conversión de dato Cast.

    -Existen varios tipos de respuestas que se pueden regresar para los cuales también existe un método derivado de controller que nos crea el objeto y devuelve el tipo de respuesta que deseamos.
        - Tipo: ViewResult, Método: View()
        - Tipo: PartialViewResult, Método: PartialView()
        - Tipo: ContentViewResult, Método: ContentView()
        - Tipo: RedirectViewResult, Método: RedirectView()
        - Tipo: RedirectToRouteResult, Método: RedirectToAction()
        - Tipo: JsonResult, Método: Json()
        - Tipo: FileResult, Método: File()
        - Tipo: HttpNotFoundResult, Método: HttpNotFound()
        - Tipo: EmptyResult

        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            //return View(movie); // Llama a la vista de nombre Random.
            //return Content("Hello World"); // Respuesta con texto plano
            //return HttpNotFound(); // Error 404.
            // return new EmptyResult(); // Devuelve página en blanco.
            return RedirectToAction("Index", "Home", new { page = 1, sortby="name"}); // Redirecciona al método indicado con los parámetros indicados.
        }

Action Parameters
    - Son las entradas que tienen los action methods.
    - ASP.NET automáticamente convierte los parámetros de las peticiones http en parámetros que reciban los action methods.
    - Los formatos en los que ASP.NET puede recibir los parámetros son:
        - En la URL: movies/edit/1
        - En una consulta tipo string: /movies/edit?id=1 
        - En tipo form data: id=1
    - Método que acepta parámetro distinto a id.
        public ActionResult Edit(int movieId)
        {
            return Content("id=" + movieId);
        }
    - Para declarar parámetros opcionales y evitar que la pagina se caiga se usan tipo nullable y una validación:
        // Declaración de parámetros tipo nullable para poder ser opcionales.
        public ActionResult Index(int? pageIndex, string sortBy) 
        {
            if (!pageIndex.HasValue)
            {
                pageIndex = 1;
            }
            if (String.IsNullOrWhiteSpace(sortBy))
            {
                sortBy = "Name";
            }

            return Content($"pageIndex={pageIndex} & sortBy{sortBy}");
        }
    
Rutas Personalizadas
    Las rutas personalizadas se añaden en:
        App_Start/RouteConfig.cs
    - Añadir una ruta personalizada:
        routes.MapRoute( // Creación de ruta personalizada.
                    name: "MoviesByReleaseDate",
                    url: "movies/released/{year}/{month}",
                    defaults: new { controller = "Movies", action = "ByReleaseDate"},
                    constraints: new { year = @"\d{4}", month = @"\d{2}" } // Expresión regular a cumplir 4 dígitos para el año y 2 dígitos para el mes.
                );
    - Acción para recibir los parámetros de la ruta personalizada.
        public ActionResult ByReleaseDate(int year, int month)
        {
            return Content($"year: {year}, month: {month}");
        }

Attribute Routing
    - Si se usa la configuración de routing con las "magic string", tendrá problemas como:
        - Tener muchas rutas declaradas convirtiendolas en un laberinto.
        - Estar cambiando entre archivos para agregar las rutas.
        - Al realizar un refactoring automático sobre la acción, no se altera el magic string y muestra el error hasta que se trata de invocar la rutas.
    - Attribute routing permite definir la ruta por encima del método haciéndolo más descriptivo y fácil de identificar.
    - Para activar attribute routing se debe ejecutar en RegisterRoutes()
        routes.MapMvcAttributeRoutes();
    - Para hacer asignar una ruta se usa:
        [Route("movies/release/{year}/{month:regex(\\d{2}:range(1,12)}")]
        public ActionResult ByReleaseYear(int year, int month)
        {
            return Content($"year: {year}, month: {month}");
        }
    - En attribut routing se define la ruta con [Route(url)].
    - Para asignar restricciones a las variables se usa ":" y el tipo de restricción a usar.
        - :regex(\\d{2}) : Función para concordar con la expresión regular.
        - :range(1,12) : Función que acepta dentro de un rango de números.
        - :range(1,12) : Función que acepta dentro de un rango de números.
    - Algunas restricciones para poder aplicar son:
        - alpha, {x:alpha} : Coincide si es una letra del alfabeto (a-z) (A-Z).
        - bool, {x:bool} : Coincide si es un dato booleano.
        - datetime, {x:datetime} : Coincide si es un valor Datetime.
        - decimal, {x:decimal} : Coincide si es un valor decimal.
        - double, {x:double} : Coincide si es un valor de punto flotante de 64 bits.
        - float, {x:float} : Coincide si es un valor de punto flotante de 32 bits.
        - guid, {x:guid} : Coincide si es un valor GUID.
        - int, {x:int} : Coincide si es un entero de 32 bits.
        - length, {x:length(6)} o {x:length(1,20)} : Coincide si una cadena tiene la longitud especificada.
        - long, {x:long} : Coincide si es es un entero de 64 bits. 
        - max, {x:max(10)} : Coincide si el entero está dentro del maximo.
        - maxlength, {x:maxlength(10)} : Coincide si la cadena está dentro del maximo. 
        - min, {x:min(10)} : Coincide si el entero está dentro del mínimo.
        - minlength, {x:minlength(10)} : Coincide si la cadena está dentro del mínimo. 
        - range, {x:range(10,50)} : Coincide si el entero está dentro del rango. 
        - regex, {x:regex(^\d{3}-\d{3}-\d{4}$)} : Coincide si la cadena cumple con la expresión regular.
    - Documentación: https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2

Pasar información a la vista.
    - Todos las vistas y controladores tienen un diccionario llamado ViewData que nos permite pasar valores a la vista, View Data es de tipo ViewDataDictionary, ViewData tiene el problema de magic string.
        - Método del controlador.
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            ViewData["Movie"] = movie; //Guarda en el diccionario la variable movie.
            return View(); // Llama a la vista de nombre Random.
        }
        - Vista con ViewBag (se necesita importar el modelo con using y hacer un cast para hacer uso del diccionario).
        @using Vidly.Models

        @{
            ViewBag.Title = "Random";
            Layout = "~/Views/Shared/_Layout.cshtml";
        }

        <h2>@(((Movie)ViewData["Movie"]).Name)</h2>
    - Las vistas también cuentan con ViewBag que permite agregar nuevas propiedades dinámicamente, por lo cual si hay un error se sabrá hasta la ejecución.
        - Método del controlador.
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            ViewBag.myMovie = movie;
            return View(); // Llama a la vista de nombre Random.
        }
        - Vista con ViewBag.
        @{
            ViewBag.Title = "Random";
            Layout = "~/Views/Shared/_Layout.cshtml";
        }

        <h2>@ViewBag.myMovie.Name</h2>
    - Implementación de model en las vistas - controladores.
        - Modelo en el controlador.
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia el modelo.
            ViewBag.myMovie = movie; // Guarda dinámicamente el objeto (no necesita casting).
            var viewResult = new ViewResult();
            viewResult.ViewData.Model = movie;
            return viewResult; // Llama a la vista de nombre Random.
        }
        - Modelo en la vista.
        @{
            ViewBag.Title = "Random";
            Layout = "~/Views/Shared/_Layout.cshtml";
        }

        <h2>@Model.Name</h2>

View Model
    - Son modelos para un tipo de datos específico como el realizar un join entre movie y customer para saber que peliculas han comprado determinadas personas.
    - Estos modelos se cargan en la definición de las listas de la misma manera, mediante el código razor se pueden ir realizando las operaciones necearias para visualizar la información.
        // Código controlador.
        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek!"}; // Instancia la película.
            var customers = new List<Customer>()
            {
                new Customer { Id = 1, Name = "Miranda" },
                new Customer { Id = 2, Name = "Merritt" },
                new Customer { Id = 3, Name = "Tad" },
                new Customer { Id = 4, Name = "Galvin" },
                new Customer { Id = 5, Name = "Allen" }
            }; // Inicializa los compradores.
            var viewModel = new RandomMovieViewModel
            {
                Movie = movie,
                Customers = customers
            }; // Inicializa view model.
            return View(viewModel); // Llama a la vista de nombre Random con viewModel.
        }

        @model Vidly.ViewModels.RandomMovieViewModel

        @{
            ViewBag.Title = "Random";
            Layout = "~/Views/Shared/_Layout.cshtml";
        }

        <h2>@Model.Movie.Name</h2>
        @if (Model.Customers.Count == 0)
        {
            <p> No one hast rented this movie before.</p>
        }
        else
        {
            <ul>
                @foreach (var customer in Model.Customers)
                {
                    <li>@customer.Name</li>
                }
            </ul>
        }
    - Sintaxis condicional con razor (Dependiendo del modelo asigna la clase popular al header o null para que no aparezca nada).
        @{ 
            var className = Model.Customers.Count() > 5 ? "popular" : null;
        }

        <h2 class="@className">@Model.Movie.Name</h2>
Partials View
    - Son las vistas que se colocan dentro de su vista padre.
    - Se acostumbra usar vistas parciales para procesar una pequeña parte de html y que asi sea mas legible el documento.
    - Las vistas parciales se añaden en shared.
    - Por convención las vistas parciales se nombran usando un guión bajo, _NombreVista.
    - Las vistas parciales no tienen Layout por defecto, pues no es la página completa a mostrar sino un segmento o componente que se agregará.
    - Para crear una vista parcial se va agregar vistas se seleciona vista parcial y se asigna un nombre y ubicación a la vista.
    - Vista parcial del navbar:
        <div class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    @Html.ActionLink("Nombre de la aplicación", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
                </div>
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li>@Html.ActionLink("Inicio", "Index", "Home")</li>
                        <li>@Html.ActionLink("Acerca de", "About", "Home")</li>
                        <li>@Html.ActionLink("Contacto", "Contact", "Home")</li>
                    </ul>
                    @Html.Partial("_LoginPartial")
                </div>
            </div>
        </div>
    - Para renderizar la vista se llama ya sea en una vista, layout o u otra vista parcial con el nombre de la vista y con un modelo como parámetro opcional:
        @Html.Partial("_NombreVista")
        @Html.Partial("_NombreVista", modelo)

Sintaxis Razor con elementos html
    <table class=“table table-striped table-hover” style="width: 100%">
        <thead>
            <tr>
                <th scope="col">Customer</th>
            </tr>
        </thead>
        <tbody class="table-striped">
            @foreach (var customer in Model)
            {
                <tr class="table-light">
                    <td> <a href="~/Customers/Details/@customer.Id">@customer.Name</a></td>
                </tr>
            }
        </tbody>
    </table>

Creando links
    - Un link puede ser declarado con la etiqueta a como comunmente se hace en html.
        - Link con etiqueta a y ruta relativa a la página (.).
            <a href="./Customers/Details/@customer.Id">@customer.Name</a>
        - Link con etiqueta a y ruta desde la raiz (~).
            <a href="~/Customers/Details/@customer.Id">@customer.Name</a>
    - Además de usar link por medio de la etiqueta a se puede usar el Html helper proveido por el framework, el cual nos posibilita referenciar directamente al controlador y la acción al que se redirigirá.
    - Con @Html.ActionLink se pasan los parámetros y clase(css) de la etiqueta por medio de un objeto anónimo.
        - Prototipos de @Html.ActionLink
            public static MvcHtmlString ActionLink(this HtmlHelper htmlHelper, string linkText, string actionName, string controllerName);
            public static MvcHtmlString ActionLink(this HtmlHelper htmlHelper, string linkText, string actionName, string controllerName, object routeValues, object htmlAttributes);
            public static MvcHtmlString ActionLink(this HtmlHelper htmlHelper, string linkText, string actionName, string controllerName, RouteValueDictionary routeValues, IDictionary<string, object> htmlAttributes);
        - Link con @Html.ActionLink sin parámetro y sin clase css.
            @Html.ActionLink("Vidly", "Index", "Home")
        - Link con @Html.ActionLink sin parámetro y con clase css.
            @Html.ActionLink("Movies", "Index", "Movies", new { area = "" }, new { @class = "nav-link" })
        - Link con @Html.ActionLink sin parámetro y con clase css.
            @Html.ActionLink("Movies", "Index", "Movies", new { area = "" }, new { @class = "nav-link" })
        - Link con @Html.ActionLink pasando parámetro id y sin clase css.
            @Html.ActionLink((string)movie.Name, "MovieDetails", "Movies", new { id = movie.Id }, null)
Entity framework
    - Es una herramienta para poder acceder acceder a una base de datos, formalmente un ORM (Object Relational Mapper), el cual mapea los datos de sql en objetos de c#.
    - Si no se usará un mapeador de datos se tendría que abrir manualmente la conexión, ejecutar la sentencia sql, leer la información, guardarla en un objeto y cerrar la conexión.
    - Entity framework nos provee una clase de tipo DbContext que es el acceso a nuestra base de datos, de ahi se escojen los dbsets(tablas) a leer en la consulta.
    - Para leer los DbSet se usa sintaxis LinQ el cual se encarga de general el SQL necesario para obtener los datos de la base de datos.
    - Al leerse los datos se guardan en el DbSet, al hacer adiciones, modificaciones o borrados en el DbSet se guardan los cambios y cuando se indica modificar entonces ejecuta los cambios en la base de datos.
Flujos de trabajo en Entity Framework
    - DbFirst: Se crea primero la base de datos y conforme a esta se generan los modelos para relacionar la base de datos con el orm.
    - CodeFirst: Se crea primero el código de los modelos y conforme a estos se crea la base de datos, se puede ir actualizando si es necesario.
    - Es mejor usar CodeFirst
        - Incrmenta la productividad (no se tienen que crear tablas manualmente).
        - Versionado total de la base de Datos.
        - Es más fácil de ralizar pruebas de integración a la base de datos.
    - Cosas que se no son verdaderas de Code-First:
        - Solo se puede usar para proyectos nuevos o en blanco.
        - No nos da el control total de la base de datos.
Pasos para integrar Entity Framework.
    - Ir a la consola en NuGet Package Manager, NuGet Package Manager Console.
    - En la consola ejecutar: 
        enable-migrations
    - Con enable-migrations se configura poder usar migraciones para tener un historial del diseño de la base de datos.
    - Se crea la primera migración con: 
        add-migration InitialModel
    - Los conjuntos para crear el DbSet los toma de Models/IdentityModels, en la clase  ApplicationDbContext la cual deriva de DbContext, por eso la toma para realizar las migraciones.
        public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
        {
            public ApplicationDbContext()
                : base("DefaultConnection", throwIfV1Schema: false)
            {
            }

            public static ApplicationDbContext Create()
            {
                return new ApplicationDbContext();
            }
        }
    - En esa misma clase se agregaran los modelos que serán considerados para ser tablas de la base de datos, en este caso la tabla Customers.

        public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
        {
            public DbSet<Customer> Customers { get; set; }

            public ApplicationDbContext()
                : base("DefaultConnection", throwIfV1Schema: false)
            {
            }

            public static ApplicationDbContext Create()
            {
                return new ApplicationDbContext();
            }
        }
    - Ya que no se han ejecutado cambios sobre la base de datos y no se incluyeron todas las tablas necesarias se puede rehacer el código de la migración con el parámetro -force:
        add-migration InitialModel -force
    - Crear la base de datos:
        update-database
    - En el explorador de soluciones dar clic en mostrar todos los archivos.
    - En la carpeta App_Data abrir el archivo .mdf generado para ver la base de datos.
Migraciones
    Las migraciones deben ser tratadas como pequeñas modificaciones que se hacen y no una modificación masiva a la estructura de la base de datos.
    - Se aconseja tener migraciones cortas y asociarles nombres referentes a lo modificación realizada.
    Agregar nueva migración:
        - add-migration AddIsSuscribedToCustomer
    Reflejar cambios en la base de datos:
        - update-database
Modelos
    - Creacion de los modelos con llaves foráneas, por convención se escribe MembershipTypeId en donde debe terminar con Id.
        public class Customer
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public bool IsSubscribedToNewsletter { get; set; }
            public MembershipType MembershipType { get; set; }
            public int MembershipTypeId { get; set; }
        }

        public class MembershipType
        {
            public int Id { get; set; }
            public float SignUpFee { get; set; }
            public byte DurationInMonths { get; set; }
            public double DiscountRate { get; set; }
        }
Sembrando la base de datos.
    Para realizar la siembra de los datos en la base de datos, entity framework nos permite agregar sentencias SQL en las migraciones con el Comando SQL:
        public partial class PopulateMembershipTypes : DbMigration
        {
            public override void Up()
            {
                Sql("INSERT INTO MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRate) VALUES (1, 0, 0, 0)");
                Sql("INSERT INTO MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRate) VALUES (2, 30, 1, 10)");
                Sql("INSERT INTO MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRate) VALUES (3, 90, 3, 15)");
                Sql("INSERT INTO MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRate) VALUES (4, 300, 12, 20)");
            }

            public override void Down()
            {
            }
        }
    - Guardar los cambios y ejecutar: update-database.
    - Los datos que se siembren en las migraciones deben ser los pensados cuando se despliega la aplicación de manera inicial, no los datos de prueba para verificar su correcta operación.

Uso de DataAnotations
    Para definir si un campo es requerido o no, o fijar distintas condiciones de la tabla se deben usar DataAnotations:
    public class Customer
    {
        public int Id { get; set; }
        [Required]
        [StringLength(255)]
        public string Name { get; set; }
        public bool IsSubscribedToNewsletter { get; set; }
        public MembershipType MembershipType { get; set; }
        public int MembershipTypeId { get; set; }
    }
    https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/data-annotations

Consulta de Datos
    Para consultar los datos se debe instanciar DbContext, este es un ejemplo sin inyección de dependencias en un controlador.
        private ApplicationDbContext _context;
        
        public CustomersController()
        {
            _context = new ApplicationDbContext();
        }

        protected override void Dispose(bool disposing)
        {
            _context.Dispose(); // Limpia dbContext de la memoria.
        }

        public ActionResult Index()
        {
            var customers = _context.Customers.ToList();
            if (customers.Count == 0)
                return View();
            return View(customers);
        }

Eager Loading
    Para traer todas las propiedades del objeto consultado, como los propiedades que también son objetos se usa eager loading, trayendo mas campos en la consulta.
    Uso de propiedad de otro objeto (join)
        <td> @customer.MembershipType.DiscountRate</td>
    Consulta con Eager Loading para traer todos los miembros indicados.
        var customers = _context.Customers.Include(c => c.MembershipType).ToList();
    Espacio de nombre para incluir método de Eager Loading.
        using System.Data.Entity;
    
Agregar nuevo campo con datos
    - Si el tipo de dato no es nulo por defecto y se requiere que sea nulo debe ser declarado en la entidad como nullable.
    public DateTime? Birthdate { get; set; }

    public override void Up()
    {
        AddColumn("dbo.Customers", "Birthdate", c => c.DateTime());
    }

    public override void Up()
    {
        AddColumn("dbo.MembershipTypes", "Name", c => c.String());
        Sql("UPDATE dbo.MembershipTypes SET Name = 'Pay as You Go' WHERE Id=1;");
        Sql("UPDATE dbo.MembershipTypes SET Name = 'Monthly' WHERE Id=2;");
        Sql("UPDATE dbo.MembershipTypes SET Name = 'Quarterly' WHERE Id=3;");
        Sql("UPDATE dbo.MembershipTypes SET Name = 'Annual' WHERE Id=4;");
    }

- Definición de Entidad con elementos foráneos.
    public class Movie
    {
        public int Id { get; set; }
        [Required]
        [StringLength(255)]
        public string Name { get; set; }
        [Required]
        public Genre Genre { get; set; }
        public int GenreId { get; set; }
        public DateTime ReleaseDate { get; set; }
        public DateTime DateAdded { get; set; }
        public int NumberInStock { get; set; }
    }

- Declaración de Modelos tipo IEnumerable:
    public ActionResult Index()
    {
        IEnumerable<Movie> movies = db.Movies.Include(m => m.Genre);
        if (movies.Count() != 0)
            return View(movies);
        return View();
    }

    @model IEnumerable<Vidly.Models.Movie>
    @foreach (var movie in Model)
    {
    <tr class="table-light">
        <td> @movie.Genre.Name</td>
    </tr>
    }

Formularios
    - Para hacer formularios ASP.NET tiene un Html Helper que se encarga de crear las etiquetas de formulario <form> </form>, limpiar el objeto de memoria (usando using) y asociarlo a una acción declarada en el controlador.
    - Formulario que pasa la información por POST en la acción Create del controlador Customers.
        @using (@Html.BeginForm("Create", "Customers"))
        {

        }
    - Para darle estilo de bootstrap se usa dentro de using:
        <div class="form-group"> </div>
    - Para declarar la etiqueta del nombre de un campo se puede usar.
        - Etiqueta por html por defecto. 
            <label for="Name"> </label>
        - Html helper (se le asigna el nombre de la propiedad sobre la cual está asignada).
            @Html.LabelFor(m => m.Name)
            Resultado en html: <label for="Name">Name</label>
    - Para cambiar el texto del label se puede definir en la entidad un Data DataAnotation para ese campo.
        [Display(Name = "Date of Birth")]
        public DateTime? Birthdate { get; set; }
    - Para declarar el campo de datos (textbox) se usa un HtmlHelper el cual nos ayuda con las validaciones definidas en las DataAnnotations
            @Html.TextBoxFor(m => m.Name)
            Resultado en html: <input data-val="true" data-val-length="El campo Name debe ser una cadena con una longitud máxima de 255." data-val-length-max="255" data-val-required="El campo Name es obligatorio." id="Name" name="Name" type="text" value="">
    - En el html TextBoxFor se puede definir la clase de la siguiente manera:
        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" } )
    - Para trabajar con formato de tipo fecha se puede usar la expresión de formato {0} indica el valor del primer parámetro.
        @Html.TextBoxFor(m => m.Customer.Birthdate, "{0:d MMM yyyy}", new { @class = "form-control" })
        @Html.TextBoxFor(m => m.Customer.Birthdate, "{0:dddd, dd MMMM yyyy}", new { @class = "form-control" })
    - Para verificar casillas booleanas se usa el HtmlHelper CheckBoxFor
        @Html.CheckBoxFor(m => m.IsSubscribedToNewsletter)

Dropdown List
    - Para crear un Dropdown List por lo general se requiere llamar las opciones de otra tabla de la base de datos por lo cual es recomenable crear su propio modelo en la carpeta con todas las ViewModels.
    - La función Html.DropdownList contiene los siguientes elementos:
        - public static MvcHtmlString DropDownListFor<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, Expression<Func<TModel, TProperty>> expression, IEnumerable<SelectListItem> selectList, string optionLabel, object htmlAttributes);
        - expresion: Función lambda con la propiedad que se referencia.
        - selectList: Objeto SelectListItem con las opciones a pasar.
        - SelectListItem: new SelectList(Model.MembershipTypes, "Id", "Name"):
            1 arg: DataItems (Valores de la lista)
            2 arg: Campo del valor (por lo general Id).
            3 arg: Campo del valor Visible (por lo general Name).
        - optionLabel: Texto por defecto del DropdownList.
        - htmlAttributes: Objeto anónimo con los atributos html (clase id).
    - Ejemplo de DropdownList:
        @Html.DropDownListFor(m => m.Customer.MembershipTypeId, new SelectList(Model.MembershipTypes, "Id", "Name"), "Select Membership Type", new { @class = "form-control" })
Data Binding
    - Al enviar la información a través de un formulario se envían los campos definidos en el formulario a traves de form data, las llaves de estos son pasados a través de POST y cuando los recibe el controlador (POST) este infiere todos los campos posibles a asignar al ojeto y los guarda.
    - Declaración de Método POST para procesar la solicitud del formulario de agregar un usuario.
        [HttpPost]
        public ActionResult Create(Customer customer)
        {
            db.Customers.Add(customer); // Agregar al contexto.
            db.SaveChanges(); // Realizar los cambios en la base de datos.

            return RedirectToAction("Index","Customers");
        }

Add-Update
    Cuando se usa una vista con un modelo definido para poder agergar o actualizar dependiendo de la acción indicada por la url, se puede agregar o editar eligiendo 2 caminos:
        - Mostrar una vista general y dependiendo si el Id no es nulo (al usar data binding es nulo para add y con valor para edit), en el controlador decidir si se agrega o se actualiza.
        - En la vista revisar si el Id es nulo y conforme al valor decidir si mostrar una vista de agregar con acción agregar al controlador o una vista editar con acción editar en el controlador.
    - Usando la primera implementación el código queda así:
        - En el controlador se lee el valor de Id.
            [HttpPost]
            public ActionResult SaveCustomer(Customer customer)
            {
                if (customer.Id <= 0) // Sin Id asignado agregar customer.
                {
                    db.Customers.Add(customer);
                }
                else // Con Id asignado actualizar customer.
                {
                    var updated_customer = db.Customers.FirstOrDefault(c => c.Id.Equals(customer.Id));
                    updated_customer.Name = customer.Name;
                    updated_customer.MembershipTypeId = customer.MembershipTypeId;
                    updated_customer.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
                    //TryUpdateModel(updated_customer, "", new string[] { "Name", "MembershipTypeId", "IsSubscribedToNewsletter" });
                }
                db.SaveChanges();
                return RedirectToAction("Index","Customers");
            }
        - En la vista se agrega el campo del Id escondido.
            @Html.HiddenFor(m => m.Customer.Id)
            @Html.HiddenFor(m => m.Movie.Id, new { Value = idValue })
    - Para actualizar la información con métodos automáticos de transferencia de datos se puede usar
        TryUpdateModel(updated_customer, "", new string[] { "Name", "MembershipTypeId", "IsSubscribedToNewsletter" });
        Mapper.Map(customer, updated_customer)
    - Consejos para actualizar.
        Cuando se trabaja con varias secciones de código y varias acciones como agregar y actualizar conviene hacer todo en pasos pequeños e ir validando parte por parte aun sabiendo que el método o la vista no contempla aun todos los casos.
        En particular para una vista que actualice y agrege, primero hay que configurar todo para que agregue y luego para que actualice.


Validaciones con Data Annotations
    - Las Data Annotations no solo son usadas para asignar las restricciones y propiedades de la entidad (tabla) o para usarlas con Display y mostrar el label deseado, sino que también son usadas para validar el modelo y mostrar los mensajes en la vista.
    - Para usar las validaciones del modelo ingresado por el parámetro se llama a la función, con esto sabra si el parámetro ingresado cumple con las Data Annotations que se declararon:
        ModelState.IsValid
    - Para reflejar en la vista se usa el html helper ValidationMessagesFor, el cual al verificar el modelo se actualiza:
        - Html Helper:
            @Html.ValidationMessageFor(m => m.Customer.Name)
        - Etiqueta generada sin error y con error.
            <span class="field-validation-valid" data-valmsg-for="Customer.Name" data-valmsg-replace="true"></span>
            <span class="field-validation-error" data-valmsg-for="Customer.Name" data-valmsg-replace="true">El campo Name es obligatorio.</span>
    - Para las validaciones se pueden seguir 3 pasos.
        - Declarar las Data Annotations en las entidades.
        - Usar ModelState.IsValid en el controlador POST para verificar que la entidad sea válida.
        - Agregar validaciones a la vista del formulario.

Agregar estílos CSS para cada toda la página.
    - Se accede a contents y a site.css se añaden los estilos que se quieran usar, al ser una página que siempre requiere una vista se configura en site.css que es el archivo del _Layout por defecto.
    - Una forma de resaltar los campos es usando las clases que agrega Model.IsValid a los elementos.
        Resalta el texto en rojo del mensaje.
        .field-validation-error {
            color: red;
        }
        Coloca las cajas de texto o de selección en rojo.
        .input-validation-error {
            border: 4px solid red;
        }

DataAnnotations
    - Algunas Data Annotations posible son:
        [Required]
        [StringLength(255)]
        [Range(1,10)]
        [Compare("Other Property")]
        [Phone]
        [EmailAddress]
        [Url]
        [RegularExpresion""]
    - Para sobrescribir el mensaje de error de las validaciones se usa la propiedad ErrorMessage de cada validación.
        [Required(ErrorMessage = "Please enter customer's name.")]
        [StringLength(255, ErrorMessage = "The maximun string length can be 255 characters.")]

Validaciones Personalizadas
    Para realizar nuestras propias validaciones podemos crear nuestra propia Data Annotation que recibe el modelo a validar y conforme a eso lo válida.
    - Para usar la validación se hereda de la clase:
        ValidationAttribute
    - Se debe sobrescribir el método IsValid:
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    - Si la validación indica que el modelo es válido se envia:
        ValidationResult.Success
    - Si la validación indica que el modelo no es válido se envia:
        new ValidationResult(ErrorMessage = "Mensaje de error.")
    - Creación de validación personalizada heredando de Validation Attribute.
        public class Min18YearsIfAMember : ValidationAttribute
        {
            protected override ValidationResult IsValid(object value, ValidationContext validationContext)
            {
                Customer customer = (Customer)validationContext.ObjectInstance;

                if (customer.MembershipTypeId == 0 || customer.MembershipTypeId == 1)
                    return ValidationResult.Success;

                if (customer.Birthdate == null)
                    return new ValidationResult(ErrorMessage = "Birthdate is required.");

                int age = CalculateAge(customer.Birthdate.Value);

                bool HasMoreThan18Years = (age >= 18);

                return HasMoreThan18Years
                    ? ValidationResult.Success
                    : new ValidationResult("Customer should be at least 18 years old to go on a membership.");

            }

            private int CalculateAge(DateTime birth)
            {
                DateTime today = DateTime.UtcNow.Date;
                var age = today.Year - birth.Year;

                // Si es mayor en mes o si es mayor en dias pero del mismo mes.
                if (birth.Month > today.Month ||
                    (birth.Month == today.Month && birth.Day > today.Day))
                {
                    age--;
                }

                return age;
            }
        }

Manteneabilidad de la lógica del negocio.
    - Cuando se usa código que va referente a la lógica del negocio, es preferente usar variables que expliquen el código y no solo una referencia númerica como en el caso de la membresía.
        if (customer.MembershipTypeId == 0 || customer.MembershipTypeId == 1)
                    return ValidationResult.Success;
    - Cuando se usan variables hard-code estan pueden ser vulnerables y no mantenibles a lo largo del ciclo de vida del código por lo cual es recomendabel asignar un enum o una variable de solo lectura estática.
    - Para declarar una variable de lectura estática se asigna como un atributo dentro del código de clase del modelo.
        public class MembershipType
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public float SignUpFee { get; set; }
            public byte DurationInMonths { get; set; }
            public double DiscountRate { get; set; }

            public static readonly int Unknown = 0;
            public static readonly int PayAsYouGo = 1;
        }
    - Actualizando el código queda asignado de la siguiente manera.
        if (customer.MembershipTypeId == MembershipType.Unknown ||
                customer.MembershipTypeId == MembershipType.PayAsYouGo)
                return ValidationResult.Success;

Validation Sumary
    - Con validation summary podemos mostrar todos los campos del modelo que no cumplen las condiciones en un solo bloque con la instrucción:
        @Html.ValidationSummary()
    - Cuando se usa ValidationSummary en la vista se debe considerar cada campo del formulario a evaluar en especial el Id del formulario cuando se va agregar un nuevo registro, ya que también incluye la validación para ese campo.
    - Una manera de evitar el mensaje de error para la validación del Id es inicializando el valor del Id en 0 desde el controlador de la vista esto se puede hacer asignando el objeto pertinente al modelo de la vista como en el siguiente caso.
        public ActionResult AddCustomer()
        {
            var membershipTypes = db.MembershipTypes.ToList();
            var viewmodel = new CustomerFormViewModel
            {
                Customer = new Customer(), //Asignación de un nuevo objeto con Id=0 por defecto.
                MembershipTypes = membershipTypes
            };
            return View("CustomerForm", viewmodel);
        }
    - Otra solución es asignar un valor al id ya sea para cuando es agregar o actualizar, usando viewBag o usando razor para verificar el modelo:
        @{
            bool isUpdating = !(Model.Movie == null || Model.Movie.Id == 0);
            string title = isUpdating ? "Update Movie" : "Add New Movie";
            int idValue = isUpdating ? Model.Movie.Id : 0;
        }
        @Html.HiddenFor(m => m.Movie.Id, new { Value = idValue })
    - Adicionalmente se puede configurar si se desea mantener los detalles de los errores en el resumen y si se quiere un mensaje general que indique que hay errores, estos se pasan en el primer y segundo parámetro de la función respectivamente.
        - Muestra mensaje general y mensaje para cada error.
            - Html Helper:
                @Html.ValidationSummary(false, "Please fix the following errors:")
            - Etiquetas generadas:
                <div class="validation-summary-errors" data-valmsg-summary="true">
                    <span>Please fix the following errors:</span>
                    <ul>
                        <li>Please enter customer's name.</li>
                        <li>Please select the Membership Type Id.</li>
                    </ul>
                </div>
        - Solo muestra mensaje general muestra mensaje general.
            - Html Helper:
            @Html.ValidationSummary(true, "Please fix the following errors:")
            - Etiquetas generadas:
            <div class="validation-summary-errors">
                <span>Please fix the following errors:</span>
                <ul>
                    <li style="display:none"></li>
                </ul>
            </div>

Validaciones del lado del cliente.
    - El usuario tiene una respuesta casi inmediata.
    - No se gastan recursos del lado del servidor.
    - En el layout la función RenderSection nos permite colocar código de js en la vista.
        @RenderSection("scripts", required: false)
    - Para usar código js en la vista se debe usar:
        @section scripts
        {
            @Scripts.Render("~/bundles/jqueryval")    
        }
    - Las Data Annotations al momento de compilarse pueden usar las validaciones unobstructiva (que no afectan al servidor) si se llama el código js correspondiente en la vista:
            @section scripts
            {
                @Scripts.Render("~/bundles/jqueryval")    
            }
    - Los validadores de js funcionan leyendo el contenido de los tags y conforme al contenido puede verificar si la validación es correcta o no.
    - Las validaciones disponibles del lado del cliente en Data Annotation son:
        [Required]
        [StringLength(255)]
        [Range(1, 10)]
        [Compare("OtherProperty")]
        [Phone]
        [EmailAddress]
        [Url]
        [RegularExpresion("...")]
        
Anti-Forgery-Token
    Son tokens para comprobar la identidad del usuario y que solo admina request válidas que fueron generadas desde la página.
    - Cross-site Request Forgery: Es un método de ataque al usuario donde desde un sitio malicioso se hace una petición POST para modificar o acceder a los datos del usuario.
    - Con un HtmlHelper podemos defender a nuestra aplicación de ese tipo de ataques usando [ValidateAntiForgeryToken] en la acción del controlador y @Html.AntiForgeryToken() en la vista para por medio de una cookie con el token correcto poder validar que la petición vino del sitio permitido.
        
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult SaveCustomer(Customer customer)
        {
            ...
        }

        @Html.AntiForgeryToken()

Programación con API
    - Cuando se usa una API solo se devuelve la información desde el servidor sin tener que devolver todo el html de lo cual se encarga el cliente, esto nos ayuda en varios aspectos como:
        - Menos recursos usados por el servidor.
        - Menos transferencia de datos.
        - Conectividad con varios clientes como web, escritorio y app.
    - Algunas API que son públicas proveen sus datos para complementar la experiencia de navegación con sus funcionalidades y no tener que repetir todo el trabajo.
    - El framework ASP.NET Web API es distinto al de ASP.NET MVC pero sigue los mismos principios de arquitectura.

Covención Restful
    Son API que usan los verbos http en conjunto con un Endpoint para realizar distintas acciones, generalmente referentes al CRUD.
        - GET /api/customers
        - GET /api/customers/1
        - POST /api/customers
        - PUT /api/customers/1
        - DELETE /api/customers/1
    REST significa Representational State Transfer
    